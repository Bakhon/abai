{
    "collab_server" : "",
    "contents" : "// Copyright © 2016 RTE Réseau de transport d’électricité\n(function() {\n  var d3 = require(\"d3\");\n  var minicharts = require(\"minicharts\");\n  var utils = require(\"./utils.js\");\n\n  L.Minichart = L.CircleMarker.extend({\n    /** Options used to initialize/update a Minichart object.\n      * @typedef {object} MinichartOptions\n      * @memberOf 'L.Minichart'\n      * @prop {string} [type = \"bar\"]\n      * Type of chart to create. Possible values are \"bar\" for barcharts, \"pie\"\n      * for pie charts, \"polar-radius\" and \"polar-area\" for polar area charts\n      * where values are represented either by the radius or the area of the\n      * slices.\n      * @prop {number[]} [data = [1]]\n      * Data values the chart has to represent.\n      * @prop {number[]|\"auto\"} [maxValues = \"auto\"]\n      * maximal absolute value the data could take. It can be a single numeric\n      * value or an array of values with same length as data. In the first case,\n      * all values will be represented with the same scale while in the second\n      * case, each value will have its own scale. This is useful when one wants\n      * to represent multiple variables that are not comparable. If it equals to\n      * \"auto\" (the default) then the maximum absolute value in data is used.\n      * @prop {string[]} [colors=d3.schemeCategory10] Array of colors. If its\n      * length is less than the length of data, colors are recycled.\n      * @prop {number} [width=60]\n      * Width of the chart when `type` equals 'bar' or maximal diameter of the\n      * chart for all other types.\n      * @prop {number} [height=60]\n      * Maximal height of barcharts.\n      * @prop {string[]|\"none\"|\"auto\"}[labels=\"none\"]\n      * Labels to display on the chart. If it equals to \"auto\" then data values\n      * are displayed in a compact way.\n      * @prop {number} [labelMinSize=8]\n      * Labels are automatically hidden if the label height is less than this number.\n      * @prop {number} [labelMaxSize=24]\n      * Maximal height of labels in pixels.\n      * @prop {number} [labelPadding=2]\n      * Padding to apply to labels.\n      * @prop {string} [labelStyle=\"font-family:sans-serif\"]\n      * CSS style to apply to labels\n      * @prop {string} [labelColor=\"auto\"]\n      * Color to apply to labels. If \"auto\", text will be black or white\n      * depending on the background color.\n      * @prop {number} [transitionTime=750]\n      * Duration in millisecondq of transitions.\n      *\n      */\n    options: {\n      type: \"bar\",\n      data: [1],\n      maxValues: \"auto\",\n      colors: d3.schemeCategory10,\n      width: 60,\n      height: 60,\n      opacity: 1,\n      labels:\"none\",\n      labelMinSize: 8,\n      labelMaxSize: 24,\n      labelPadding: 2,\n      labelColor: \"auto\",\n      labelStyle: \"font-family:sans-serif\",\n      transitionTime: 750\n    },\n\n    /**\n      * @class 'L.Minichart'\n      * @summary add add bar, pie and polar charts to a leaflet map\n      * @desc L.Minichart is used to add dynamic charts on a leaflet map. It is specially\n      * useful to represent multiple data values associated to some geographical\n      * coordinates.\n      *\n      * @example\n      *\n      * L.minichart([0, 0], {data: [1, 2, 3], maxValues: 3})\n      *\n      * @param {L.Point} center\n      * @param {MinichartOptions} options - Object containing\n      * options to construct a chart.\n      */\n    initialize: function(center, options) {\n      this._center = center;\n      this._zoom = 0;\n      this.options = utils.mergeOptions(options, this.options);\n      this._setMaxValue();\n\n      L.CircleMarker.prototype.initialize.call(\n        this,\n        center,\n        {radius: this.options.width/2, stroke: false, fill: false}\n      );\n    },\n\n    onAdd: function(map) {\n      L.CircleMarker.prototype.onAdd.call(this, map);\n      // Change class of container so that the element hides when zooming\n      var container = this._container || this._renderer._rootGroup;\n      container.setAttribute(\"class\", \"leaflet-zoom-hide\");\n\n      // create the svg element that holds the chart\n      this._chart = d3.select(container).append(\"g\");\n\n      if (L.version >= \"1.0\") this.addInteractiveTarget(this._chart.node());\n\n      map.on('moveend', this._onMoveend, this);\n\n      this._redraw(true);\n    },\n\n    onRemove: function(map) {\n      // remove layer's DOM elements and listeners\n      L.CircleMarker.prototype.onRemove.call(this, map);\n      this._chart.selectAll(\"*\").remove();\n      map.off('moveend', this._onMoveend, this);\n    },\n\n    _onMoveend: function() {\n      // Redraw chart only if zoom has changed\n      var oldZoom = this._zoom;\n      this._zoom = this._map.getZoom();\n      if (oldZoom != this._zoom) this._redraw() ;\n    },\n\n    /** Update the options of a minichart object.\n      * @method setOptions\n      * @instance\n      * @memberOf 'L.Minichart'\n      *\n      * @param {MinichartOptions} options - Object containing options to update the chart.\n      */\n    setOptions: function(options) {\n      var newChart = options.type && options.type != this.options.type;\n      this.options = utils.mergeOptions(options, this.options);\n      this._setMaxValue();\n      this._redraw(newChart);\n    },\n\n    _setMaxValue: function() {\n      // Max absolute value for each variable\n      var max = this.options.maxValues;\n      var data = utils.toArray(this.options.data);\n      if (max === \"auto\") {\n        max = Math.max(\n          d3.max(data),\n          Math.abs(d3.min(data))\n        )\n        if (max == 0) max = 1;\n      }\n\n      max = utils.toArray(max);\n\n      if(max.length !== 1 && max.length != data.length) {\n        throw new Error(\"'maxValues' should be a single number or have same length as 'data'\");\n      }\n\n      for (var i = 0; i < data.length; i++) {\n        if (Math.abs(data[i]) > max[i % max.length]) {\n          console.warn(\"Some data values are greater than 'maxValues'.\" +\n                       \" Chart will be truncated. You should set option 'maxValues'\" +\n                       \" to avoid this problem.\");\n          break;\n        }\n      }\n\n      this.options.maxValues = max;\n    },\n\n    _redraw: function(newChart) {\n      // Move container on the map\n      var c = this._map.latLngToLayerPoint(this._center);\n      var h;\n      if (this.options.type == \"bar\") {\n        h = this.options.height * 2;\n      } else {\n        h = this.options.width;\n      }\n      this._chart\n        .attr(\"transform\", \"translate(\" + (c.x - this.options.width / 2) + \",\" + (c.y - h / 2) + \")\")\n        .transition()\n        .duration(this.options.transitionTime)\n        .attr(\"opacity\", this.options.opacity);\n\n      // prepare data\n      var data = this.options.data;\n      data = utils.toArray(data);\n      for (var i = 0; i < data.length; i++) {\n        if (isNaN(data[i]) || !isFinite(data[i])) data[i] = 0;\n      }\n      var max = this.options.maxValues;\n      // Scale data. This step is essential to have different scales for each\n      // variable. Only relevant if chart is not a pie/\n      var dataScaled = [];\n\n      if (this.options.type == \"pie\") {\n        dataScaled = data;\n      } else {\n        for (var i = 0; i < data.length; i++) {\n          dataScaled.push(data[i] / max[i % max.length]);\n        }\n      }\n\n      // Prepare labels\n      var labels = this.options.labels;\n      if (labels === \"auto\") {\n        labels = utils.prettyNumbers(data);\n      }\n\n      // Generator function\n      var generator, type;\n      switch(this.options.type) {\n        case \"bar\":\n          generator = minicharts.Barchart;\n          break;\n        case \"pie\":\n          generator = minicharts.Piechart;\n          break;\n        case \"polar-radius\":\n          generator = minicharts.Polarchart;\n          type = \"radius\";\n          break;\n        case \"polar-area\":\n          generator = minicharts.Polarchart;\n          type = \"area\";\n          break;\n      }\n\n      // Graphical options for the generator function\n      var chartOpts = {\n        width: this.options.width,\n        height: this.options.height * 2, // Used only if type = \"bar\"\n        colors: this.options.colors,\n        type: type,\n        transitionTime: this.options.transitionTime,\n        minValue: -1,\n        maxValue:1,\n        labels: labels,\n        labelColors: this.options.labelColor,\n        labelMinSize: this.options.labelMinSize,\n        labelMaxSize: this.options.labelMaxSize,\n        labelPadding: this.options.labelPadding,\n        labelClass: \"leaflet-clickable leaflet-interactive\",\n        shapeClass: \"leaflet-clickable leaflet-interactive\"\n      };\n\n      // Create of update chart\n      if (newChart === true) {\n        this._chart.selectAll(\"*\").remove();\n        this._chartObject = new generator(this._chart.node(), dataScaled, chartOpts);\n      } else {\n        this._chartObject.update(dataScaled, chartOpts);\n      }\n    }\n  });\n\n  L.minichart = function(center, options) {\n  return new L.Minichart(center, options);\n};\n})();\n",
    "created" : 1528460356344.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2694974954",
    "id" : "507F5BF9",
    "lastKnownWriteTime" : 1528461156,
    "last_content_update" : 1528461156492,
    "path" : "~/git/leaflet.minichart/src/minichart.js",
    "project_path" : "src/minichart.js",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "js"
}